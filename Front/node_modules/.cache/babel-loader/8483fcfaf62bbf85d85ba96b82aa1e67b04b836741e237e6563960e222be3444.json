{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useState, useEffect } from 'react';\nimport axios from 'axios';\n\n/**\n * Personalized hook to fetch data from the API\n *\n * @param {string} path specific path to fetch data {optional}\n * @param {string} option specific option to fetch data {optional}\n * @returns {Array} data, isError, loading, errorMessage\n */\nconst useFetch = ( /** @type {string} */path, /** @type {string} */option) => {\n  _s();\n  // Define the state\n  const [url, setUrl] = useState(null);\n  const [data, setData] = useState({});\n  const [loading, setLoading] = useState(true);\n  const [{\n    isError,\n    errorMessage\n  }, setError] = useState({\n    isError: false,\n    errorMessage: ''\n  });\n  useEffect(() => {\n    // If there no path provided, we use the JSON server url\n    const urlToFetch = path ? path : 'http://localhost:8080/';\n    setUrl(urlToFetch);\n    if (!url) return;\n    if (option) {\n      setLoading(true);\n\n      // Fetch the datas from the JSON-Server\n      const fetchDatas = async ( /** @type {string} */url, /** @type {string} */option) => {\n        try {\n          const response = await axios.get(url);\n          setData(response);\n          // const datas = response.data;\n          const datas = JSON.parse(response.data.result[0].json);\n          const filteredDatas = datas[option];\n          // We convert the filteredDatas to an array\n          const renderedDatas = Object.keys(filteredDatas).map(key => filteredDatas[key]);\n          setData(renderedDatas);\n          setLoading(false);\n        } catch (error) {\n          setError({\n            isError: true,\n            errorMessage: error.message\n          });\n          setLoading(false);\n        }\n      };\n      fetchDatas(url, option);\n    } else {\n      setLoading(true);\n\n      // Fetch the datas from the JSON-Server\n      const fetchDatas = async ( /** @type {string} */url) => {\n        try {\n          const response = await axios.get(url);\n          const datas = JSON.parse(response.data.result[0].json);\n          setData(datas);\n          setLoading(false);\n        } catch (error) {\n          setError({\n            isError: true,\n            errorMessage: error.message\n          });\n          setLoading(false);\n        }\n      };\n      fetchDatas(url);\n    }\n  }, [url, option, path]);\n  return [data, isError, loading, errorMessage];\n};\n_s(useFetch, \"avni4xqqCGfD4siXfWKeUDWRK98=\");\nexport default useFetch;","map":{"version":3,"names":["useState","useEffect","axios","useFetch","path","option","_s","url","setUrl","data","setData","loading","setLoading","isError","errorMessage","setError","urlToFetch","fetchDatas","response","get","datas","JSON","parse","result","json","filteredDatas","renderedDatas","Object","keys","map","key","error","message"],"sources":["/Users/sebastien/Sebbe's Cloud/Dev/Projects/Privates/guepes-et-frelons/src/utils/hooks/useFetchJson.jsx"],"sourcesContent":["import { useState, useEffect } from 'react';\nimport axios from 'axios';\n\n/**\n * Personalized hook to fetch data from the API\n *\n * @param {string} path specific path to fetch data {optional}\n * @param {string} option specific option to fetch data {optional}\n * @returns {Array} data, isError, loading, errorMessage\n */\nconst useFetch = (/** @type {string} */ path, /** @type {string} */ option) => {\n\t// Define the state\n\tconst [url, setUrl] = useState(null);\n\tconst [data, setData] = useState({});\n\tconst [loading, setLoading] = useState(true);\n\tconst [{ isError, errorMessage }, setError] = useState({ isError: false, errorMessage: '' });\n\n\tuseEffect(() => {\n\t\t// If there no path provided, we use the JSON server url\n\t\tconst urlToFetch = path ? path : 'http://localhost:8080/';\n\t\tsetUrl(urlToFetch);\n\t\tif (!url) return;\n\n\t\tif (option) {\n\t\t\tsetLoading(true);\n\n\t\t\t// Fetch the datas from the JSON-Server\n\t\t\tconst fetchDatas = async (/** @type {string} */ url, /** @type {string} */ option) => {\n\t\t\t\ttry {\n\t\t\t\t\tconst response = await axios.get(url);\n\t\t\t\t\tsetData(response);\n\t\t\t\t\t// const datas = response.data;\n\t\t\t\t\tconst datas = JSON.parse(response.data.result[0].json);\n\t\t\t\t\tconst filteredDatas = datas[option];\n\t\t\t\t\t// We convert the filteredDatas to an array\n\t\t\t\t\tconst renderedDatas = Object.keys(filteredDatas).map((key) => filteredDatas[key]);\n\t\t\t\t\tsetData(renderedDatas);\n\t\t\t\t\tsetLoading(false);\n\t\t\t\t} catch (error) {\n\t\t\t\t\tsetError({ isError: true, errorMessage: error.message });\n\t\t\t\t\tsetLoading(false);\n\t\t\t\t}\n\t\t\t};\n\t\t\tfetchDatas(url, option);\n\t\t} else {\n\t\t\tsetLoading(true);\n\n\t\t\t// Fetch the datas from the JSON-Server\n\t\t\tconst fetchDatas = async (/** @type {string} */ url) => {\n\t\t\t\ttry {\n\t\t\t\t\tconst response = await axios.get(url);\n\t\t\t\t\tconst datas = JSON.parse(response.data.result[0].json);\n\t\t\t\t\tsetData(datas);\n\t\t\t\t\tsetLoading(false);\n\t\t\t\t} catch (error) {\n\t\t\t\t\tsetError({ isError: true, errorMessage: error.message });\n\t\t\t\t\tsetLoading(false);\n\t\t\t\t}\n\t\t\t};\n\t\t\tfetchDatas(url);\n\t\t}\n\t}, [url, option, path]);\n\n\treturn [data, isError, loading, errorMessage];\n};\n\nexport default useFetch;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}